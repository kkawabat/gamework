The goal is to build a general-purpose framework for online board games that runs with minimal operational cost. The games are designed to be played with friends, so trust is 100% assumed and there is no concern about cheating or abuse. The system should be serverless in practice, using only static hosting and a minimal signaling channel.

The chosen architecture is host-authoritative. One device (often an iPad) acts as the host and main display, maintaining the authoritative game state and running all rules. Other devices (playersâ€™ phones, laptops, etc.) act as controllers, sending input messages to the host. The host then broadcasts updated game state back to all peers. This pattern supports both turn-based and light realtime/party-style games and keeps complexity low.

Communication happens over WebRTC DataChannels, with a small signaling mechanism (Cloudflare Worker, Firebase, etc.) used only for peer discovery and initial connection setup. STUN servers help establish connections; TURN is optional and can be added later if connectivity issues arise.

The game loop is driven by a simple message protocol:

Join: a player connects and receives a snapshot of the current state.

Input: players send actions or moves to the host.

State: the host applies moves using a pure reducer function and broadcasts either a patch or occasional full snapshot.

Resync: if a client falls behind, it can request a fresh snapshot.

The game state is always a single serializable object, versioned to allow resynchronization. For persistence, the host can optionally export/import the state as JSON.

On the UX side, the iPad host is treated as the central game board. It should run as a PWA to be installable fullscreen and use wake locks to prevent the display from sleeping. Players can join easily via QR code invites that link to a room code handled through the signaling system.

This framework is meant to be reusable across multiple games: the networking, host logic, and state synchronization are generic. To create a new game, a developer only needs to define:

The game state schema.

The applyMove reducer that transforms state given a player action.

The UI rendering logic for host and clients.

Optional extensions include host migration (if the host disconnects, another device can take over), cloud persistence for replays or saved games, and simple logging for debugging.